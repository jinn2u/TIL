## **🌱 var 전역변수**

- 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다.
- 변수는 자신이 등록된 스코프가 소멸될떄까지 유효하다.
- 따라서 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.
- 전역변수는 오직 함수레벨 스코프를 따른다. 따라서 for 나 if 문등의 블록레벨 스코프는 인정하지 않는다.
- 또한 호이스팅이 일어나기 때문에 프로그램의 흐름이 맞지 않고 가독성을 떨어트린다.
- 암묵적으로 선언단계와 초기화단계가 한번에 실행된다.
- var로 선언한 전역변수는 전역객체 window의 프로퍼티가 된다.

## **🌱  전역변수 사용의 억제**

### 1. 즉시 실행 함수

```js
(function(){
   var foo = 10;
   //
}())
console.log(foo); // foo is not defined

```

- 모든 코드를 즉시 실행함수로 감싸면 모든 변수는 즉시 실행함수의 지역변수가 된다.
- 이 방법을 사용하면 전역변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.

### 2.네임스페이스 객체

```js
var MYAPP = {}
MYAPP.name = 'Lee'
MYAPP.person = {
   name: "Kim",
   address: 'Seoul'
}
console.log(MYAPP.person);
```

- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.
- 네임스페이스를 분리해서 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역변수에 할당되므로 그다지 유용하지는 않다.

### 3. 모듈 패턴

```js
var Counter = (function(){
   // private 변수
   var num = 0
   // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
   return {
      increase(){
         return ++ num;
      },
      decrease(){
         return --num;
      }
   }
}())

console.log(Counter.num); //undefined
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
```

- 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행함수로 가싸 하나의 모듈을 만든다.
- 클로저를 기반으로 동작한다.
- 전역변수의 억제와 캡슐화까지 구현할 수 있다.

### 4. ES6 모듈

```js
<script type="module" src = 'lib.mjs'></script>
```

- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.
- 하지만 트랜스파일링이나 번들링이 필요하기 때문에 webpack등의 모듈 번들러를 사용하는것이 일반적이다.