## 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 constructor프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정지을 수 없다.

  ```js
  const obj = {}
  
  // 객체 리터럴로 생성했지만 obj 객체는 Object 생성자 함수와 constructor 프로퍼티와 연결되어 있다.
  console.log(obj.constructor === Object); // true
  ```

- Object 생성자 함수 호출과 객체 리터럴의 평가는 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점에서는 동일하지만, new.target의 확인이나 프로퍼티를 추가하는 처리등 세부 내용은 다르다. 따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.

- 함수 객체의 경우 Function 생성자 함수를 호출하여 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인것처럼 스코프를 생성하며 클로저도 만들지 않는다.

  ```js
  // foo함수는 Function 생성자 함수로 생성한 함수객체가 아니라 함수 선언문으로 생성하였다.
  function foo(){}
  
  // 하지만 constructor프로퍼티를 통해 확인해보면 함수 foo의 생성자 함수는 Function 생성자 함수이다.
  console.log(foo.constructor === Function) // true
  ```

- 리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다. 따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다.
- 즉, 프로토타입과 생성자함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.(프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor프로퍼티에 의해 연결된다.)

- 하지만 큰틀에서 생각해보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서는 차이가 없다.