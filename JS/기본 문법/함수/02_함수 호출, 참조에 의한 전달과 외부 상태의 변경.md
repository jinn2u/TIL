## 🌱  함수 호출

- 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.
- 즉 매개변수의 스코프는 함수 내부이다.
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 안흔ㄴ다.
- 인수가 부족한 경우, 인수가 할당되지 않은 매개변수의 값은 undefined이다.
- 매개변수보다 인수가 더 많은 경우, 초과된 인수는 무시된다.
- 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관되기 때문에 초과된 인수는 그냥 버려지는것이 아니라.

<hr />

## 🌱  참조에 의한 전달과 외부 상태의 변경

- 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.

```js
function changeVal(primitive, obj){
   primitive += 100;
   obj.name = 'Kim';
}

var num = 100; // let도 동일하게 동작한다.
var person = {name: 'Lee'};

console.log(num);
console.log(person);

changeVal(num, person); 
console.log(num); // 100
console.log(person); // {name: 'Kim'}
```

- changeVal 함수는 매개변수를 통해 전달받은 원시타입 인수와 객체 타입 인수를 함수몸체에서 변경한다.
- primitive의 경우, num이 원시타입이기 떄문에 변경 불가능한 값이므로 직접 변경할 수 없기 때문에 재할당을 통해 할당된 원시 값을 새로운 원시값으로 교체하였다.
- obj의 경우 객체는 메모리를 참조하기 때문에 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본 객체가 변경되는 부수효과가 발생한다.
- 이럴 경우 상태 변화를 추적하기가 어려워진다. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이다.

<hr />

### 🍏 해결 방법

- 옵저버 패턴
    - 객체의 변경을 추적하려면 옵저버 패턴을 통해 객체의 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다.
- 불변 객체
    - 객체의 복사본을 새롭개 생성하는 비용은 들지만, 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만든다.
    - 이를 통해 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우, 객체의 방어적 복사, 즉 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다. 이를 통해 외부 상태가 변경되는 부수 효과를 없앨수 있다.
- 순수 함수와 함수형 프로그래밍
    - 이처럼 외부 상태를 변경하지 않고 외부상태에 의존하지도 않는 함수를 순수 함수라 한다.
    - 순수함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.